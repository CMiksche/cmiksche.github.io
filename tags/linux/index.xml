<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux on M5E&#39;s Blog</title>
    <link>https://blog.m5e.de/tags/linux/</link>
    <description>Recent content in linux on M5E&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 06 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.m5e.de/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux: Setup ZITADEL with PostgreSQL</title>
      <link>https://blog.m5e.de/post/linux-setup-zitadel-with-postgresql/</link>
      <pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m5e.de/post/linux-setup-zitadel-with-postgresql/</guid>
      <description>In this Guide, I want to cover installing ZITADEL with PostgreSQL on a Linux system. Please be aware that PostgreSQL support is still in Beta at the time of this writing, and you will need a PostgreSQL installation with Version 14 or higher.
NGINX Proxy Create a new subdomain and point it to your server. Use certbot -d domain.name for creating a new SSL Cert. Create a new file in /etc/nginx/sites-available/domainname</description>
      <content>&lt;p&gt;In this Guide, I want to cover installing ZITADEL with PostgreSQL on a Linux system. Please be aware that PostgreSQL support is still in Beta at the time of this writing, and you will need a PostgreSQL installation with Version 14 or higher.&lt;/p&gt;
&lt;h2 id=&#34;nginx-proxy&#34;&gt;NGINX Proxy&lt;/h2&gt;
&lt;p&gt;Create a new subdomain and point it to your server. Use &lt;code&gt;certbot -d domain.name&lt;/code&gt; for creating a new SSL Cert. Create a new file in &lt;code&gt;/etc/nginx/sites-available/domainname&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    server_name domain.com;

    listen 443 ssl;

    ssl_certificate     /etc/letsencrypt/live/domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/domain.com/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot

    location / {
        grpc_pass grpc://localhost:8080;
        grpc_set_header Host $host:$server_port;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;postgresql&#34;&gt;PostgreSQL&lt;/h2&gt;
&lt;p&gt;We need a database for the software. This can be created by the following commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo -u postgres psql
postgres=# create database zitadel;
postgres=# create user zitadel with encrypted password &#39;mypass&#39;;
postgres=# grant all privileges on database zitadel to zitadel;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;config-file&#34;&gt;Config File&lt;/h2&gt;
&lt;p&gt;I often create directories for software in &lt;code&gt;/opt/projectname&lt;/code&gt;. Then a &lt;code&gt;config.yaml&lt;/code&gt; file could look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ExternalSecure: true
ExternalDomain: &#39;domain.name&#39;
ExternalPort: 443

Database:
    postgres:
        Host: localhost
        Port: 5432
        Database: zitadel
        MaxOpenConns: 25
        MaxConnLifetime: 1h
        MaxConnIdleTime: 5m
        Options:
        User:
            Username: zitadel
            Password: zitadel
            SSL:
                Mode: disable
                RootCert:
                Cert:
                Key:
        Admin:
            Username: postgres
            Password: postgres
            SSL:
                Mode: disable
                RootCert:
                Cert:
                Key:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We should also create an &lt;code&gt;init.yaml&lt;/code&gt; file like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FirstInstance:
    Org:
        Human:
        # use the loginname root@zitadel.localhost
        Username: &#39;root&#39;
        Password: &#39;RootPassword1!&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;
&lt;p&gt;Use the following command to download and install Zitadel:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LATEST=$(curl -i https://github.com/zitadel/zitadel/releases/latest | grep location: | cut -d &#39;/&#39; -f 8 | tr -d &#39;\r&#39;); wget -qO-  https://github.com/zitadel/zitadel/releases/download/$LATEST/zitadel_Linux_$(uname -m).tar.gz  | tar -xz zitadel &amp;amp;&amp;amp; sudo mv zitadel /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;masterkey&#34;&gt;Masterkey&lt;/h2&gt;
&lt;p&gt;We should generate and save an masterkey:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;$(tr -dc A-Za-z0-9 &amp;lt;/dev/urandom | head -c 32)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;start&#34;&gt;Start&lt;/h2&gt;
&lt;p&gt;For the first run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;zitadel start-from-init \
    --config /opt/zitadel/config.yaml \
    --steps /opt/zitadel/init.yaml \
    --masterkey &amp;quot;${ZITADEL_MASTERKEY}&amp;quot; \
    --tlsMode external
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now visit &lt;code&gt;https://domain.name/ui/console&lt;/code&gt; and you can log in.&lt;/p&gt;
&lt;p&gt;If your custom username and password don&amp;rsquo;t work, then try out the default account:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;username: &lt;code&gt;root@zitadel.localhost&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;password: &lt;code&gt;RootPassword1!&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After that, you can start it with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;zitadel start \
    --config /opt/zitadel/config.yaml \
    --masterkey &amp;quot;${ZITADEL_MASTERKEY}&amp;quot; \
    --tlsMode external
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I currently encounter an &lt;a href=&#34;https://github.com/zitadel/zitadel/issues/4330&#34;&gt;Issue&lt;/a&gt; with the &lt;code&gt;start&lt;/code&gt; command which could be connected with the beta state of the PostgreSQL support.&lt;/p&gt;
&lt;h2 id=&#34;systemd-daemon&#34;&gt;Systemd Daemon&lt;/h2&gt;
&lt;p&gt;I also set up a custom systemd daemon. For that, create a new file in &lt;code&gt;/etc/systemd/system&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Unit]
Description=Custom Zitadel
After=postgresql.service

[Service]
RestartSec=2s
Type=simple
User=zitadel
WorkingDirectory=/opt/zitadel
ExecStart=/usr/local/bin/zitadel start-from-init --config /opt/zitadel/config.ya
ml --masterkey YOUR_MASTERKEY --tlsMode external
Environment=USER=root HOME=/opt/zitadel
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target&lt;/code&gt;&lt;/pre&gt;
</content>
    </item>
    
    <item>
      <title>The Reason why Linux Gaming is so limited</title>
      <link>https://blog.m5e.de/post/the-reason-why-linux-gaming-is-so-limited/</link>
      <pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m5e.de/post/the-reason-why-linux-gaming-is-so-limited/</guid>
      <description>Ever tried Gaming on a Linux system? Even though Linux exists since more than 30 years now, it is still hard to play a Game on it. Most Games don&amp;rsquo;t even publish a release for Linux. That&amp;rsquo;s why projects like Wine exist (Wine provides a compatibility layer so that Linux Users can play Windows Games)
Why is it like that? For that, we need to understand how a Game works and how a Game Developer thinks.</description>
      <content>&lt;p&gt;Ever tried Gaming on a Linux system? Even though Linux exists since more than 30 years now, it is still hard to play a Game on it. Most Games don&amp;rsquo;t even publish a release for Linux. That&amp;rsquo;s why projects like Wine exist (Wine provides a compatibility layer so that Linux Users can play Windows Games)&lt;/p&gt;
&lt;h2 id=&#34;why-is-it-like-that&#34;&gt;Why is it like that?&lt;/h2&gt;
&lt;p&gt;For that, we need to understand how a Game works and how a Game Developer thinks. Game Developer need to earn money so that they can buy e.g. food. For that, targeting a big Group of Customers is important.&lt;/p&gt;
&lt;p&gt;When a Game Developer writes a Game, he doesn&amp;rsquo;t want to write separate Code for every GPU / CPU. In the early days of computing (e.g. the C64 and Atari days), this was the case. Back then, developer wrote code for every different GPU and CPU. This is very time-consuming and if Companies would still act like that, we would have to wait even longer for the e.g. next GTA 6 Game or the next Elder Scrolls.&lt;/p&gt;
&lt;p&gt;Then Companies like Microsoft and Silicon Graphics came. These companies did something really great for all Game Developers. They provided APIs which can be accessed by one Interface and which handle the different GPUs for you.
This means, a Game Developer only has to write the code once and these APIs handle the rest. Now publishing a Game for different computers is easier.&lt;/p&gt;
&lt;p&gt;This APIs are named DirectX (from Microsoft) and OpenGL. Because DirectX is from Microsoft, the API was only available for Windows. OpenGL on the other hand is available for a wide range of Operating Systems.
OpenGL is also Open Source which means every developer can take a look at the code.&lt;/p&gt;
&lt;p&gt;Now, if you can think logical, you already found the reason why Linux Gaming is so limited. The question about the Availability of Games is a Question about which API is more successful.&lt;/p&gt;
&lt;p&gt;Most people use Windows. Microsoft provides DirectX for Game Development, so most Game Developers choose DirectX as API platform because they can reach most of the people by that.&lt;/p&gt;
&lt;p&gt;If OpenGL would be more successful, then we would have more Games for Linux because OpenGL is compatible with Linux.&lt;/p&gt;
&lt;h2 id=&#34;the-future&#34;&gt;The Future&lt;/h2&gt;
&lt;p&gt;In the past, Game Developers used OpenGL because they could target Windows, Linux and macOS. Apple however, decided to deprecate OpenGL APIs on all of their platforms because they now have their own proprietary &amp;ldquo;Metal&amp;rdquo; API.&lt;/p&gt;
&lt;p&gt;Many features (like Ray tracing) are only available in these proprietary APIs.&lt;/p&gt;
&lt;p&gt;So probably many developers will still choose proprietary APIs like DirectX or Metal in the future because they provide better features which result in better Games.&lt;/p&gt;
&lt;p&gt;The reason behind this is that companies like Microsoft and Apple want that. They earn way more money that way. Developers have to pay fees and if they use a Windows-only or Apple-only API, then this will result into exclusive titles which are only available on one platform and customers will choose the platform with the better exclusive titles.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Forget Bash, take Python!</title>
      <link>https://blog.m5e.de/bash/script/python/linux/2020/05/22/forget-bash-take-python.html</link>
      <pubDate>Fri, 22 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m5e.de/bash/script/python/linux/2020/05/22/forget-bash-take-python.html</guid>
      <description>I wrote bash scripts for several years now. You can find old bash scripts of mine on GitHub but most of them aren&amp;rsquo;t maintained anymore - and I have a reason for that.
But before I give you my reasons for not using many bash scripts anymore, lets look at the benefits of bash:
It super easy and you basically already can it if you write Linux / BSD commands There are frameworks out now which give you advanced features like testing It works out of the box on nearly every Linux / BSD system Okay - sounds good - so what&amp;rsquo;s my problem?</description>
      <content>&lt;p&gt;I wrote bash scripts for several years now. You can find old bash scripts of mine on GitHub but most of them aren&amp;rsquo;t maintained anymore - and I have a reason for that.&lt;/p&gt;
&lt;p&gt;But before I give you my reasons for not using many bash scripts anymore, lets look at the benefits of bash:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It super easy and you basically already can it if you write Linux / BSD commands&lt;/li&gt;
&lt;li&gt;There are frameworks out now which give you advanced features like testing&lt;/li&gt;
&lt;li&gt;It works out of the box on nearly every Linux / BSD system&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Okay - sounds good - so what&amp;rsquo;s my problem?&lt;/p&gt;
&lt;p&gt;Bash is limited. E.g. it doesn&amp;rsquo;t work out of the box in Windows and I switched my default shell in Linux to fish. But let&amp;rsquo;s break down a few points why Bash isn&amp;rsquo;t optimal for me:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You tend to write platform specific code - e.g. I switched from Debian to Arch Linux and had to replace the &lt;code&gt;apt-get&lt;/code&gt; commands with &lt;code&gt;pacman&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;I use fish as default shell. You can use Bash-Scripts with fish, but it&amp;rsquo;s more complicated &amp;hellip;&lt;/li&gt;
&lt;li&gt;Linux isn&amp;rsquo;t my only operating system - I run Windows and macOS machines as well.&lt;/li&gt;
&lt;li&gt;I love features of higher level programming languages like Python.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And how does Python solve this problem?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It runs out of the box on many Linux systems&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s cross-platform - the same code can run under Linux, Windows, macOS, &amp;hellip; but you also can check the current system and write platform specific code for that&lt;/li&gt;
&lt;li&gt;It is also super easy and makes fun&lt;/li&gt;
&lt;li&gt;Testing and more advanced features are build in - no need to install packages&lt;/li&gt;
&lt;li&gt;Like bash, it is already used for automating tasks in many systems (so you can find tons of help online)&lt;/li&gt;
&lt;li&gt;You can simply access the operating system&lt;/li&gt;
&lt;li&gt;Distribution is also very simple - just create a package and pip can install it from the PyPI, private registry or a Git-Repo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Languages like Go would also be interesting for automating tasks in your Linux system but Go has things like pointers and types. Python is more similar to Bash - very simple without advanced topics like types or pointers.&lt;/p&gt;
&lt;p&gt;I created many python scripts for things which solved bash scripts before. And my python scripts all have unit tests and detect the current running operating system. Whereas my bash scripts only worked on Debian systems do my python scripts work on all my used operating systems. So it has saved me a lot of work.&lt;/p&gt;
&lt;p&gt;But I also continue to use little bash scripts for simple tasks like &amp;ldquo;open this on startup&amp;rdquo; - I think it&amp;rsquo;s important to be aware, that higher level languages like python have a big benefit if you want to switch your system but use the same scripts.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>