<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Authentication on M5E&#39;s Blog</title>
    <link>https://blog.m5e.de/tags/Authentication/</link>
    <description>Recent content in Authentication on M5E&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 22 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.m5e.de/tags/Authentication/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>State of OpenID Connect Providers</title>
      <link>https://blog.m5e.de/post/state-of-openid-connect-providers/</link>
      <pubDate>Thu, 22 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m5e.de/post/state-of-openid-connect-providers/</guid>
      <description>In the last days I tried to integrate multiple OpenID Connect Providers into my Applications (currently mostly Alphalerts and some dev projects)
So far, I only got Google to work, and even this is currently limited to 100 Users. In this blog post, I want to explain why the integration of OpenID Connect Providers is such a struggle by showing multiple examples.
But before I show the examples, you should know that there are not so many big OpenID Connect Providers compared to the big OAuth2 Providers.</description>
      <content>&lt;p&gt;In the last days I tried to integrate multiple OpenID Connect Providers into my Applications (currently mostly &lt;a href=&#34;https://alphalerts.com&#34;&gt;Alphalerts&lt;/a&gt; and some dev projects)&lt;/p&gt;
&lt;p&gt;So far, I only got Google to work, and even this is currently limited to 100 Users. In this blog post, I want to explain why the integration of OpenID Connect Providers is such a struggle by showing multiple examples.&lt;/p&gt;
&lt;p&gt;But before I show the examples, you should know that there are not so many big OpenID Connect Providers compared to the big OAuth2 Providers. E.g. GitHub offers OAuth2, but is not a OpenID Connect Provider yet.&lt;/p&gt;
&lt;p&gt;For reference, I use &lt;a href=&#34;https://blog.m5e.de/post/linux-setup-zitadel-with-postgresql/&#34;&gt;Zitadel&lt;/a&gt; as my own OpenID Connect Instance.&lt;/p&gt;
&lt;h2 id=&#34;openid-connect&#34;&gt;OpenID Connect&lt;/h2&gt;
&lt;p&gt;OpenID Connect is a protocol that allows users to authenticate themselves using a third-party service, such as Google or Microsoft, instead of creating a new account specifically for the service they are trying to access.&lt;/p&gt;
&lt;p&gt;When a user wants to log in to a service that uses OpenID Connect, they are redirected to the third-party service to enter their login credentials. If the credentials are valid, the third-party service sends a unique token back to the service the user was trying to access, which confirms the user&amp;rsquo;s identity. This process allows users to easily log in to multiple services without having to remember multiple usernames and passwords, and it also allows service providers to authenticate users without having to store sensitive login information.&lt;/p&gt;
&lt;h2 id=&#34;the-difference-to-oauth2&#34;&gt;The Difference to OAuth2&lt;/h2&gt;
&lt;p&gt;OAuth2 is a protocol that allows a user to grant limited access to their resources stored on one site, to another site, without having to disclose their login credentials. It is commonly used as a way for users to log in to third-party applications using their social media or other online accounts, without sharing their password.&lt;/p&gt;
&lt;p&gt;OpenID Connect is built on top of OAuth2 and provides an additional layer of authentication on top of the authorization provided by OAuth2. While OAuth2 is focused on authorization and allows a user to grant access to their resources to another site, OpenID Connect adds the ability for the user to be authenticated and for the client to know the user&amp;rsquo;s identity. In other words, OAuth2 allows a user to authorize a client to access their resources, while OpenID Connect allows the client to authenticate the user and determine their identity.&lt;/p&gt;
&lt;p&gt;So OAuth2 is a protocol for authorization, while OpenID Connect is a protocol for authentication and identity management. OAuth2 is used to grant access to resources, while OpenID Connect is used to verify the user&amp;rsquo;s identity and provide information about the user, such as their name and email address.&lt;/p&gt;
&lt;h2 id=&#34;google&#34;&gt;Google&lt;/h2&gt;
&lt;p&gt;Google offers the best OpenID Connect implementation I have seen so far. You can set multiple callback / redirect URLs, which many Providers don&amp;rsquo;t offer yet.&lt;/p&gt;
&lt;p&gt;There are just a few problems: If you set a Logo, your Application needs to be checked by a Google Employee and if you don&amp;rsquo;t get checked, your App is limited to 100 Users.&lt;/p&gt;
&lt;h2 id=&#34;gitlab&#34;&gt;GitLab&lt;/h2&gt;
&lt;p&gt;I couldn&amp;rsquo;t set up GitLab with Zitadel because GitLab doesn&amp;rsquo;t fully implement the OpenID Connect Spec.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;prompt=consent&lt;/code&gt; and &lt;code&gt;prompt=select_account&lt;/code&gt; are not yet implemented by GitLab, but someone created a &lt;a href=&#34;https://gitlab.com/gitlab-org/gitlab/-/issues/377368&#34;&gt;Issue&lt;/a&gt; for that.&lt;/p&gt;
&lt;h2 id=&#34;yahoo&#34;&gt;Yahoo&lt;/h2&gt;
&lt;p&gt;Yahoo gives me a different problem. After the discovery document, they support &lt;code&gt;RS256&lt;/code&gt; and &lt;code&gt;ES256&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But currently, Yahoo always responds with &lt;code&gt;ES256&lt;/code&gt;. Because Zitadel currently just supports &lt;code&gt;RS256&lt;/code&gt;, this results in an error.&lt;/p&gt;
&lt;p&gt;Other providers like netID, to which I come next, offer a dropdown menu in the Application creation step which lets you choose the algorithm. I send Yahoo an Email about this.&lt;/p&gt;
&lt;h2 id=&#34;netid&#34;&gt;netID&lt;/h2&gt;
&lt;p&gt;netID is a Foundation which was established in March 2018 by Mediengruppe RTL Deutschland, ProSiebenSat.1 and United Internet AG. The foundation pursues the goal of establishing netID as a European alternative to US single sign-on providers.&lt;/p&gt;
&lt;p&gt;In difference to Yahoo, netID gives you the option to select &lt;code&gt;RS256&lt;/code&gt; or &lt;code&gt;ES256&lt;/code&gt; which is pretty nice.&lt;/p&gt;
&lt;p&gt;However, netID only lets you define one Callback URL currently. Zitadel uses two different URLs for register and login, which makes this incompatible.&lt;/p&gt;
&lt;p&gt;I also send a Mail to netID asking them to implement multiple Callback URLs.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;OpenID Connect itself is pretty nice but despite being around since 2014, most providers just offer OAuth2 and the few providers which offer OpenID Connect have either not fully implemented the Spec or other weird Issues which makes it hard to use them.&lt;/p&gt;
&lt;p&gt;Currently, it seems like you would have to write custom code for every different Provider - but exactly that should be prevented by such a Spec.&lt;/p&gt;
&lt;p&gt;If you are interested in custom software development, you can &lt;a href=&#34;https://chapati.systems/development/&#34;&gt;take a look&lt;/a&gt; at my company.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Linux: Setup ZITADEL with PostgreSQL</title>
      <link>https://blog.m5e.de/post/linux-setup-zitadel-with-postgresql/</link>
      <pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m5e.de/post/linux-setup-zitadel-with-postgresql/</guid>
      <description>In this Guide, I want to cover installing ZITADEL with PostgreSQL on a Linux system. Please be aware that PostgreSQL support is still in Beta at the time of this writing, and you will need a PostgreSQL installation with Version 14 or higher.
NGINX Proxy Create a new subdomain and point it to your server. Use certbot -d domain.name for creating a new SSL Cert. Create a new file in /etc/nginx/sites-available/domainname</description>
      <content>&lt;p&gt;In this Guide, I want to cover installing ZITADEL with PostgreSQL on a Linux system. Please be aware that PostgreSQL support is still in Beta at the time of this writing, and you will need a PostgreSQL installation with Version 14 or higher.&lt;/p&gt;
&lt;h2 id=&#34;nginx-proxy&#34;&gt;NGINX Proxy&lt;/h2&gt;
&lt;p&gt;Create a new subdomain and point it to your server. Use &lt;code&gt;certbot -d domain.name&lt;/code&gt; for creating a new SSL Cert. Create a new file in &lt;code&gt;/etc/nginx/sites-available/domainname&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    server_name domain.com;

    listen 443 ssl;

    ssl_certificate     /etc/letsencrypt/live/domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/domain.com/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot

    location / {
        grpc_pass grpc://localhost:8080;
        grpc_set_header Host $host:$server_port;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;caddy&#34;&gt;Caddy&lt;/h2&gt;
&lt;p&gt;For caddy, the following Config should be set in the &lt;code&gt;Caddyfile&lt;/code&gt; (e.g. &lt;code&gt;/etc/caddy/Caddyfile&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;domain.com {
    reverse_proxy h2c://localhost:8080
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;postgresql&#34;&gt;PostgreSQL&lt;/h2&gt;
&lt;p&gt;We need a database for the software. This can be created by the following commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo -u postgres psql
postgres=# create database zitadel;
postgres=# create user zitadel with encrypted password &#39;mypass&#39;;
postgres=# grant all privileges on database zitadel to zitadel;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;config-file&#34;&gt;Config File&lt;/h2&gt;
&lt;p&gt;I often create directories for software in &lt;code&gt;/opt/projectname&lt;/code&gt;. Then a &lt;code&gt;config.yaml&lt;/code&gt; file could look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ExternalSecure: true
ExternalDomain: &#39;domain.name&#39;
ExternalPort: 443

Database:
    postgres:
        Host: localhost
        Port: 5432
        Database: zitadel
        MaxOpenConns: 25
        MaxConnLifetime: 1h
        MaxConnIdleTime: 5m
        Options:
        User:
            Username: zitadel
            Password: zitadel
            SSL:
                Mode: disable
                RootCert:
                Cert:
                Key:
        Admin:
            Username: postgres
            Password: postgres
            SSL:
                Mode: disable
                RootCert:
                Cert:
                Key:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We should also create an &lt;code&gt;init.yaml&lt;/code&gt; file like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FirstInstance:
    Org:
        Human:
        # use the loginname root@zitadel.localhost
        Username: &#39;root&#39;
        Password: &#39;RootPassword1!&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;
&lt;p&gt;Use the following command to download and install Zitadel:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LATEST=$(curl -i https://github.com/zitadel/zitadel/releases/latest | grep location: | cut -d &#39;/&#39; -f 8 | tr -d &#39;\r&#39;); wget -qO-  https://github.com/zitadel/zitadel/releases/download/$LATEST/zitadel_Linux_$(uname -m).tar.gz  | tar -xz zitadel &amp;amp;&amp;amp; sudo mv zitadel /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;masterkey&#34;&gt;Masterkey&lt;/h2&gt;
&lt;p&gt;We should generate and save an masterkey:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;$(tr -dc A-Za-z0-9 &amp;lt;/dev/urandom | head -c 32)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;start&#34;&gt;Start&lt;/h2&gt;
&lt;p&gt;For the first run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;zitadel start-from-init \
    --config /opt/zitadel/config.yaml \
    --steps /opt/zitadel/init.yaml \
    --masterkey &amp;quot;${ZITADEL_MASTERKEY}&amp;quot; \
    --tlsMode external
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now visit &lt;code&gt;https://domain.name/ui/console&lt;/code&gt; and you can log in.&lt;/p&gt;
&lt;p&gt;If your custom username and password don&amp;rsquo;t work, then try out the default account:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;username: &lt;code&gt;root@zitadel.localhost&lt;/code&gt; or &lt;code&gt;zitadel-admin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;password: &lt;code&gt;RootPassword1!&lt;/code&gt; or &lt;code&gt;Password1!&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After that, you can start it with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;zitadel start \
    --config /opt/zitadel/config.yaml \
    --masterkey &amp;quot;${ZITADEL_MASTERKEY}&amp;quot; \
    --tlsMode external
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;systemd-daemon&#34;&gt;Systemd Daemon&lt;/h2&gt;
&lt;p&gt;I also set up a custom systemd daemon. For that, create a new file in &lt;code&gt;/etc/systemd/system&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Unit]
Description=Custom Zitadel
After=postgresql.service

[Service]
RestartSec=2s
Type=simple
User=zitadel
WorkingDirectory=/opt/zitadel
ExecStart=/usr/local/bin/zitadel start --config /opt/zitadel/config.ya
ml --masterkey YOUR_MASTERKEY --tlsMode external
Environment=USER=zitadel HOME=/opt/zitadel
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;That was it. Surprisingly easy. The ZITADEL team is also really fast responding to problems. I had some issues with the beta software, and all of these issues were fixed after a few days.&lt;/p&gt;
&lt;p&gt;This post was even mentioned by their company account:&lt;/p&gt;

  &lt;blockquote class=&#34;twitter-tweet&#34; data-dnt=&#34;true&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Thank you &lt;a href=&#34;https://twitter.com/CMiksche?ref_src=twsrc%5Etfw&#34;&gt;@CMiksche&lt;/a&gt; for creating this awesome guide 🙏🏻 We are sure it will help people getting started with ZITADEL using &lt;a href=&#34;https://twitter.com/hashtag/postgreSQL?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#postgreSQL&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/hashtag/NGINX?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#NGINX&lt;/a&gt; &lt;a href=&#34;https://t.co/DGGDIuiDFJ&#34;&gt;https://t.co/DGGDIuiDFJ&lt;/a&gt;&lt;/p&gt;&amp;mdash; ZITADEL (@zitadel) &lt;a href=&#34;https://twitter.com/zitadel/status/1567445067308187651?ref_src=twsrc%5Etfw&#34;&gt;September 7, 2022&lt;/a&gt;&lt;/blockquote&gt;


&lt;h2 id=&#34;want-to-keep-your-zitadel-uptodate&#34;&gt;Want to keep your Zitadel uptodate?&lt;/h2&gt;
&lt;p&gt;Checkout &lt;a href=&#34;https://chapati.systems/autoupdate/&#34;&gt;Autoupdate&lt;/a&gt;. One tool to update various software which has no built-in auto update functionality.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Open Source Authentication Solutions</title>
      <link>https://blog.m5e.de/post/open-source-authentication-solutions/</link>
      <pubDate>Mon, 05 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m5e.de/post/open-source-authentication-solutions/</guid>
      <description>Imagine you run a company and provide multiple web applications for your customers. In the beginning, you probably created a user table and the authentication methods yourself, but from the second application onwards, you will think about using already made open source solutions.
That&amp;rsquo;s the situation I am in right now. I run multiple web applications, which each have their own auth mechanisms and user tables. This means, a user from App1 can&amp;rsquo;t use App2 unless he creates a new account.</description>
      <content>&lt;p&gt;Imagine you run a company and provide multiple web applications for your customers. In the beginning, you probably created a user table and the authentication methods yourself, but from the second application onwards, you will think about using already made open source solutions.&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s the situation I am in right now. I run multiple web applications, which each have their own auth mechanisms and user tables. This means, a user from App1 can&amp;rsquo;t use App2 unless he creates a new account.&lt;/p&gt;
&lt;h2 id=&#34;oauth&#34;&gt;OAuth&lt;/h2&gt;
&lt;p&gt;Before I proceed, let&amp;rsquo;s have a short look how OAuth works:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OAuth Clients: That&amp;rsquo;s your typical web application which offers a login via 3rd parties like Google and Facebook&lt;/li&gt;
&lt;li&gt;OAuth Servers / Providers: That is an identity provider like e.g. Google or Facebook&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you add OAuth to your app, most of the time you just add a OAuth client. That means, customers can log in with existing accounts from other services like Google or Facebook. But they can&amp;rsquo;t use their account at your app for logging into other apps.&lt;/p&gt;
&lt;p&gt;When you provide a OAuth server, customers can log in into your applications and also login into 3rd party applications via the API of your identity server.&lt;/p&gt;
&lt;h3 id=&#34;what-oauth-means-in-my-case&#34;&gt;What OAuth means in my case&lt;/h3&gt;
&lt;p&gt;If I would just add OAuth client functionality to my apps, then users could use e.g. their Google Account for all my apps, but my apps wouldn&amp;rsquo;t be connected with each other. Every single app would be displayed as 3rd party on the Google website, and every single app would need to authenticate with Google.&lt;/p&gt;
&lt;p&gt;Because I want to provide one login for all Apps (single sign-on - SSO), just adding a OAuth client like most apps do, wouldn&amp;rsquo;t solve this problem.&lt;/p&gt;
&lt;p&gt;I need a OAuth server which provides one single identity and one single login to all my apps. This means, all my apps become OAuth clients of my own OAuth server and my OAuth server itself is e.g. a OAuth client for other OAuth servers like Google.
That way, a user could log in into my OAuth server with his existing Google Account and then continue to use all my apps.&lt;/p&gt;
&lt;p&gt;So far the theory, now let&amp;rsquo;s look at the realization.&lt;/p&gt;
&lt;h2 id=&#34;backend-as-a-service-baas&#34;&gt;Backend-as-a-Service (BaaS)&lt;/h2&gt;
&lt;p&gt;In the modern world, solutions like Supabase, PocketBase, Firebase, Appwrite or Parse Server are getting used more and more. One of the reasons is because they handle authentication for you.&lt;/p&gt;
&lt;p&gt;There is just one big catch: Nearly all the BaaS solutions are just OAuth Clients! Every single application which you create on them will get their own user table and additionally, you often can&amp;rsquo;t connect custom OAuth Servers but only the popular ones like Google, Facebook, Twitter, GitHub,&amp;hellip;&lt;/p&gt;
&lt;p&gt;So my problem wouldn&amp;rsquo;t be solved, because I would still have different user tables and separate login processes. So every single app would be displayed on the Google website as a different OAuth client.&lt;/p&gt;
&lt;h2 id=&#34;openid-connect--oauth2-servers&#34;&gt;OpenID Connect / OAuth2 Servers&lt;/h2&gt;
&lt;p&gt;Maybe you have already heard of applications like Keycloak, Ory Hydra, ZITADEL and SuperTokens. These are all auth providers which basically allow you to become some Identity provider like Google yourself.&lt;/p&gt;
&lt;p&gt;It could be, that you already run a OAuth2 server without knowing it. E.g. Gitea has such a functionality built-in. I configured my Gitea instance to act as a OAuth server for e.g. my continuous integration and project management applications. I recently also found out, that my ERP Systems would also support auth via OAuth2, so I could set up all the apps inside my company to work just with the Gitea user auth.&lt;/p&gt;
&lt;p&gt;If you set up an identity server like ZITADEL, then you have to integrate it into all your apps which may be time-consuming in the beginning, but it is absolutely rewarding:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You will never have to create a user table again&lt;/li&gt;
&lt;li&gt;Login isn&amp;rsquo;t different for every app, but handled by one service only&lt;/li&gt;
&lt;li&gt;If users are logged into your main provider, then all your client applications don&amp;rsquo;t need the user to enter username and password again&lt;/li&gt;
&lt;li&gt;Modern auth servers support passwordless auth like FaceID, TouchID or Windows Hello&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A bit more information about such services:&lt;/p&gt;
&lt;h3 id=&#34;keycloak&#34;&gt;Keycloak&lt;/h3&gt;
&lt;p&gt;One of the oldest and most famous auth servers. Complicated and written in Java.&lt;/p&gt;
&lt;h3 id=&#34;ory-hydra&#34;&gt;Ory Hydra&lt;/h3&gt;
&lt;p&gt;Modern, written in Go but still complicated in my opinion (Ory provides multiple packages for their auth solutions and it is hard to figure out which of them you need and how to configure them)&lt;/p&gt;
&lt;h3 id=&#34;zitadel&#34;&gt;ZITADEL&lt;/h3&gt;
&lt;p&gt;Modern, written in GoLang and in my opinion the one which is easiest to understand.&lt;/p&gt;
&lt;h3 id=&#34;supertokens&#34;&gt;SuperTokens&lt;/h3&gt;
&lt;p&gt;Another open source auth server written in Java.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;When I began exploring open source authentication solutions, I was thinking maybe some BaaS platform would help me. After figuring out what I wanted, it was clear that Backend-as-a-Service providers aren&amp;rsquo;t a solution for me and I had to look at a completely different kind of software category.&lt;/p&gt;
&lt;p&gt;I don&amp;rsquo;t know which kind of OAuth2 Server I will stick with over the long time, but I am sure that I will use them.&lt;/p&gt;
&lt;h2 id=&#34;want-to-keep-your-zitadel-instance-uptodate&#34;&gt;Want to keep your Zitadel Instance uptodate?&lt;/h2&gt;
&lt;p&gt;Checkout &lt;a href=&#34;https://chapati.systems/autoupdate/&#34;&gt;Autoupdate&lt;/a&gt;. One tool to update various software which has no built-in auto update functionality.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
